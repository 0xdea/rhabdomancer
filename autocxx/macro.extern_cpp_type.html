<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Indicates that a C++ type is not to be generated by autocxx in this case, but instead should refer to some pre-existing Rust type."><title>extern_cpp_type in autocxx - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="autocxx" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../static.files/storage-3a5871a4.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc macro"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../autocxx/index.html">autocxx</a><span class="version">0.28.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">extern_<wbr>cpp_<wbr>type</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#requirements-for-externally-defined-rust-types" title="Requirements for externally defined Rust types">Requirements for externally defined Rust types</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate autocxx</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">autocxx</a></div><h1>Macro <span class="macro">extern_cpp_type</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/autocxx/lib.rs.html#334-336">Source</a> </span></div><pre class="rust item-decl"><code>macro_rules! extern_cpp_type {
    ($($tt:tt)*) =&gt; { ... };
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Indicates that a C++ type is not to be generated by autocxx in this case,
but instead should refer to some pre-existing Rust type.</p>
<p>If you wish for the type to be POD, you can use a <code>pod!</code> directive too
(but see the “requirements” section below).</p>
<p>The syntax is:
<code>extern_cpp_type!("CppNameGoesHere", path::to::rust::type)</code></p>
<p>Generally speaking, this should be used only to refer to types
generated elsewhere by <code>autocxx</code> or <code>cxx</code> to ensure that they meet
all the right requirements. It’s possible - but fragile - to
define such types yourself.</p>
<h2 id="requirements-for-externally-defined-rust-types"><a class="doc-anchor" href="#requirements-for-externally-defined-rust-types">§</a>Requirements for externally defined Rust types</h2>
<p>It’s generally expected that you would make such a type
in Rust using a separate <code>include_cpp!</code> macro, or
a manual <code>#[cxx::bridge]</code> directive somehwere. That is, this
directive is intended mainly for use in cross-linking different
sets of bindings in different mods, rather than truly to point to novel
external types.</p>
<p>But with that in mind, here are the requirements you must stick to.</p>
<p>For non-POD external types:</p>
<ul>
<li>The size and alignment of this type <em>must</em> be correct.</li>
</ul>
<p>For POD external types:</p>
<ul>
<li>As above</li>
<li>Your type must correspond to the requirements of
<a href="../cxx/extern_type/kind/enum.Trivial.html" title="enum cxx::extern_type::kind::Trivial"><code>cxx::kind::Trivial</code></a>. In general, that means, no move constructor
and no destructor. If you generate this type using <code>cxx</code> itself
(or <code>autocxx</code>) this will be enforced using <code>static_assert</code>s
within the generated C++ code. Without using those tools, you’re
on your own for determining this… and it’s hard because the presence
of particular fields or base classes may well result in your type
violating those rules.</li>
</ul>
<p>A directive to be included inside
<a href="macro.include_cpp.html" title="macro autocxx::include_cpp">include_cpp</a> - see <a href="macro.include_cpp.html" title="macro autocxx::include_cpp">include_cpp</a> for general information.</p>
</div></details></section></div></main></body></html>