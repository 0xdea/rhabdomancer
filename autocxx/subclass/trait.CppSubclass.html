<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A subclass of a C++ type."><title>CppSubclass in autocxx::subclass - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="autocxx" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../autocxx/index.html">autocxx</a><span class="version">0.28.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">CppSubclass</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#how-to-access-your-rust-structure-from-outside" title="How to access your Rust structure from outside">How to access your Rust structure from outside</a></li><li><a href="#how-to-call-c-methods-on-the-subclass" title="How to call C++ methods on the subclass">How to call C++ methods on the subclass</a></li><li><a href="#how-to-implement-virtual-methods" title="How to implement virtual methods">How to implement virtual methods</a></li><li><a href="#how-not-to-implement-virtual-methods" title="How not to implement virtual methods">How not to implement virtual methods</a></li><li><a href="#how-it-works" title="How it works">How it works</a></li><li><a href="#limitations" title="Limitations">Limitations</a></li></ul><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.peer_holder" title="peer_holder">peer_holder</a></li><li><a href="#tymethod.peer_holder_mut" title="peer_holder_mut">peer_holder_mut</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.new_cpp_owned" title="new_cpp_owned">new_cpp_owned</a></li><li><a href="#method.new_rust_owned" title="new_rust_owned">new_rust_owned</a></li><li><a href="#method.peer" title="peer">peer</a></li><li><a href="#method.peer_mut" title="peer_mut">peer_mut</a></li></ul><h3><a href="#dyn-compatibility">Dyn Compatibility</a></h3><h3><a href="#implementors">Implementors</a></h3></section><div id="rustdoc-modnav"><h2><a href="index.html">In autocxx::<wbr>subclass</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">autocxx</a>::<wbr><a href="index.html">subclass</a></span><h1>Trait <span class="trait">CppSubclass</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/autocxx/subclass.rs.html#274-319">Source</a> </span></div><pre class="rust item-decl"><code>pub trait CppSubclass&lt;CppPeer: CppSubclassCppPeer&gt;: <a class="trait" href="trait.CppPeerConstructor.html" title="trait autocxx::subclass::CppPeerConstructor">CppPeerConstructor</a>&lt;CppPeer&gt; {
    // Required methods
    fn <a href="#tymethod.peer_holder" class="fn">peer_holder</a>(&amp;self) -&gt; &amp;CppSubclassCppPeerHolder&lt;CppPeer&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.peer_holder_mut" class="fn">peer_holder_mut</a>(&amp;mut self) -&gt; &amp;mut CppSubclassCppPeerHolder&lt;CppPeer&gt;;

    // Provided methods
    fn <a href="#method.peer" class="fn">peer</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;CppPeer</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.peer_mut" class="fn">peer_mut</a>(&amp;mut self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.85.0/core/pin/struct.Pin.html" title="struct core::pin::Pin">Pin</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;mut CppPeer</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.new_cpp_owned" class="fn">new_cpp_owned</a>(me: Self) -&gt; <a class="struct" href="../prelude/struct.UniquePtr.html" title="struct autocxx::prelude::UniquePtr">UniquePtr</a>&lt;CppPeer&gt; <a href="#" class="tooltip" data-notable-ty="UniquePtr&lt;CppPeer&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.new_rust_owned" class="fn">new_rust_owned</a>(me: Self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/rc/struct.Rc.html" title="struct alloc::rc::Rc">Rc</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.85.0/core/cell/struct.RefCell.html" title="struct core::cell::RefCell">RefCell</a>&lt;Self&gt;&gt; { ... }
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A subclass of a C++ type.</p>
<p>To create a Rust subclass of a C++ class, you must do these things:</p>
<ul>
<li>Create a <code>struct</code> to act as your subclass, and add the #<a href="../macro.subclass.html" title="macro autocxx::subclass"><code>crate::subclass</code></a> attribute.
This adds a field to your struct for autocxx record-keeping. You can
instead choose to implement <a href="trait.CppSubclass.html" title="trait autocxx::subclass::CppSubclass"><code>CppSubclass</code></a> a different way, in which case
you must provide the <a href="../macro.subclass.html" title="macro autocxx::subclass"><code>crate::subclass</code></a> inside your <a href="../macro.include_cpp.html" title="macro autocxx::include_cpp"><code>crate::include_cpp</code></a>
macro. (<code>autocxx</code> will do the required codegen for your subclass
whether it discovers a <a href="../macro.subclass.html" title="macro autocxx::subclass"><code>crate::subclass</code></a> directive inside your
<a href="../macro.include_cpp.html" title="macro autocxx::include_cpp"><code>crate::include_cpp</code></a>, or elsewhere used as an attribute macro,
or both.)</li>
<li>Use the <a href="trait.CppSubclass.html" title="trait autocxx::subclass::CppSubclass"><code>CppSubclass</code></a> trait, and instantiate the subclass using
<a href="trait.CppSubclass.html#method.new_rust_owned" title="associated function autocxx::subclass::CppSubclass::new_rust_owned"><code>CppSubclass::new_rust_owned</code></a> or <a href="trait.CppSubclass.html#method.new_cpp_owned" title="associated function autocxx::subclass::CppSubclass::new_cpp_owned"><code>CppSubclass::new_cpp_owned</code></a>
constructors. (You can use <a href="trait.CppSubclassSelfOwned.html" title="trait autocxx::subclass::CppSubclassSelfOwned"><code>CppSubclassSelfOwned</code></a> if you need that
instead; also, see <a href="trait.CppSubclassSelfOwnedDefault.html" title="trait autocxx::subclass::CppSubclassSelfOwnedDefault"><code>CppSubclassSelfOwnedDefault</code></a> and <a href="trait.CppSubclassDefault.html" title="trait autocxx::subclass::CppSubclassDefault"><code>CppSubclassDefault</code></a>
to arrange for easier constructors to exist.</li>
<li>You <em>may</em> need to implement <a href="trait.CppPeerConstructor.html" title="trait autocxx::subclass::CppPeerConstructor"><code>CppPeerConstructor</code></a> for your subclass,
but only if autocxx determines that there are multiple possible superclass
constructors so you need to call one explicitly (or if there’s a single
non-trivial superclass constructor.) autocxx will implement this trait
for you if there’s no ambiguity and FFI functions are safe to call due to
<code>autocxx::safety!</code> being used.</li>
</ul>
<h2 id="how-to-access-your-rust-structure-from-outside"><a class="doc-anchor" href="#how-to-access-your-rust-structure-from-outside">§</a>How to access your Rust structure from outside</h2>
<p>Use <a href="trait.CppSubclass.html#method.new_rust_owned" title="associated function autocxx::subclass::CppSubclass::new_rust_owned"><code>CppSubclass::new_rust_owned</code></a> then use <a href="https://doc.rust-lang.org/1.85.0/core/cell/struct.RefCell.html#method.borrow" title="method core::cell::RefCell::borrow"><code>std::cell::RefCell::borrow</code></a>
or <a href="https://doc.rust-lang.org/1.85.0/core/cell/struct.RefCell.html#method.borrow_mut" title="method core::cell::RefCell::borrow_mut"><code>std::cell::RefCell::borrow_mut</code></a> to obtain the underlying Rust struct.</p>
<h2 id="how-to-call-c-methods-on-the-subclass"><a class="doc-anchor" href="#how-to-call-c-methods-on-the-subclass">§</a>How to call C++ methods on the subclass</h2>
<p>Do the same. You should find that your subclass struct <code>impl</code>s all the
C++ methods belonging to the superclass.</p>
<h2 id="how-to-implement-virtual-methods"><a class="doc-anchor" href="#how-to-implement-virtual-methods">§</a>How to implement virtual methods</h2>
<p>Simply add an <code>impl</code> for the <code>struct</code>, implementing the relevant method.
The C++ virtual function call will be redirected to your Rust implementation.</p>
<h2 id="how-not-to-implement-virtual-methods"><a class="doc-anchor" href="#how-not-to-implement-virtual-methods">§</a>How <em>not</em> to implement virtual methods</h2>
<p>If you don’t want to implement a virtual method, don’t: the superclass
method will be called instead. Naturally, you must implement any pure virtual
methods.</p>
<h2 id="how-it-works"><a class="doc-anchor" href="#how-it-works">§</a>How it works</h2>
<p>This actually consists of two objects: this object itself and a C++-side
peer. The ownership relationship between those two things can work in three
different ways:</p>
<ol>
<li>Neither object is owned by Rust. The C++ peer is owned by a C++
<a href="../prelude/struct.UniquePtr.html" title="struct autocxx::prelude::UniquePtr"><code>UniquePtr</code></a> held elsewhere in C++. That C++ peer then owns
this Rust-side object via a strong <a href="https://doc.rust-lang.org/1.85.0/alloc/rc/struct.Rc.html" title="struct alloc::rc::Rc"><code>Rc</code></a> reference. This is the
ownership relationship set up by <a href="trait.CppSubclass.html#method.new_cpp_owned" title="associated function autocxx::subclass::CppSubclass::new_cpp_owned"><code>CppSubclass::new_cpp_owned</code></a>.</li>
<li>The object pair is owned by Rust. Specifically, by a strong
<a href="https://doc.rust-lang.org/1.85.0/alloc/rc/struct.Rc.html" title="struct alloc::rc::Rc"><code>Rc</code></a> reference to this Rust-side object. In turn, the Rust-side object
owns the C++-side peer via a <a href="../prelude/struct.UniquePtr.html" title="struct autocxx::prelude::UniquePtr"><code>UniquePtr</code></a>. This is what’s set up by
<a href="trait.CppSubclass.html#method.new_rust_owned" title="associated function autocxx::subclass::CppSubclass::new_rust_owned"><code>CppSubclass::new_rust_owned</code></a>. The C++-side peer <em>does not</em> own the Rust
object; it just has a weak pointer. (Otherwise we’d get a reference
loop and nothing would ever be freed.)</li>
<li>The object pair is self-owned and will stay around forever until
<a href="trait.CppSubclassSelfOwned.html#method.delete_self" title="method autocxx::subclass::CppSubclassSelfOwned::delete_self"><code>CppSubclassSelfOwned::delete_self</code></a> is called. In this case there’s a strong reference
from the C++ to the Rust and from the Rust to the C++. This is useful
for cases where the subclass is listening for events, and needs to
stick around until a particular event occurs then delete itself.</li>
</ol>
<h2 id="limitations"><a class="doc-anchor" href="#limitations">§</a>Limitations</h2>
<ul>
<li>
<p><em>Re-entrancy</em>. The main thing to look out for is re-entrancy. If a
(non-const) virtual method is called on your type, which then causes you
to call back into C++, which results in a <em>second</em> call into a (non-const)
virtual method, we will try to create two mutable references to your
subclass which isn’t allowed in Rust and will therefore panic.</p>
<p>A future version of autocxx may provide the option of treating all
non-const methods (in C++) as const methods on the Rust side, which will
give the option of using interior mutability (<a href="https://doc.rust-lang.org/1.85.0/core/cell/struct.RefCell.html" title="struct core::cell::RefCell"><code>std::cell::RefCell</code></a>)
for you to safely handle this situation, whilst remaining compatible
with existing C++ interfaces. If you need this, indicate support on
<a href="https://github.com/google/autocxx/issues/622">this issue</a>.</p>
</li>
<li>
<p><em>Thread safety</em>. The subclass object is not thread-safe and shouldn’t
be passed to different threads in C++. A future version of this code
will give the option to use <code>Arc</code> and <code>Mutex</code> internally rather than
<code>Rc</code> and <code>RefCell</code>, solving this problem.</p>
</li>
<li>
<p><em>Protected methods.</em> We don’t do anything clever here - they’re public.</p>
</li>
<li>
<p><em>Non-trivial class hierarchies</em>. We don’t yet consider virtual methods
on base classes of base classes. This is a temporary limitation,
<a href="https://github.com/google/autocxx/issues/610">see this issue</a>.</p>
</li>
</ul>
</div></details><h2 id="required-methods" class="section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.peer_holder" class="method"><a class="src rightside" href="../../src/autocxx/subclass.rs.html#278">Source</a><h4 class="code-header">fn <a href="#tymethod.peer_holder" class="fn">peer_holder</a>(&amp;self) -&gt; &amp;CppSubclassCppPeerHolder&lt;CppPeer&gt;</h4></section></summary><div class="docblock"><p>Return the field which holds the C++ peer object. This is normally
implemented by the #<a href="attr.is_subclass.html" title="attr autocxx::subclass::is_subclass"><code>is_subclass</code></a> macro, but you’re welcome to
implement it yourself if you prefer.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.peer_holder_mut" class="method"><a class="src rightside" href="../../src/autocxx/subclass.rs.html#283">Source</a><h4 class="code-header">fn <a href="#tymethod.peer_holder_mut" class="fn">peer_holder_mut</a>(&amp;mut self) -&gt; &amp;mut CppSubclassCppPeerHolder&lt;CppPeer&gt;</h4></section></summary><div class="docblock"><p>Return the field which holds the C++ peer object. This is normally
implemented by the #<a href="attr.is_subclass.html" title="attr autocxx::subclass::is_subclass"><code>is_subclass</code></a> macro, but you’re welcome to
implement it yourself if you prefer.</p>
</div></details></div><h2 id="provided-methods" class="section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.peer" class="method"><a class="src rightside" href="../../src/autocxx/subclass.rs.html#287-289">Source</a><h4 class="code-header">fn <a href="#method.peer" class="fn">peer</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;CppPeer</a></h4></section></summary><div class="docblock"><p>Return a reference to the C++ part of this object pair.
This can be used to register listeners, etc.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peer_mut" class="method"><a class="src rightside" href="../../src/autocxx/subclass.rs.html#293-295">Source</a><h4 class="code-header">fn <a href="#method.peer_mut" class="fn">peer_mut</a>(&amp;mut self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.85.0/core/pin/struct.Pin.html" title="struct core::pin::Pin">Pin</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;mut CppPeer</a>&gt;</h4></section></summary><div class="docblock"><p>Return a mutable reference to the C++ part of this object pair.
This can be used to register listeners, etc.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new_cpp_owned" class="method"><a class="src rightside" href="../../src/autocxx/subclass.rs.html#300-307">Source</a><h4 class="code-header">fn <a href="#method.new_cpp_owned" class="fn">new_cpp_owned</a>(me: Self) -&gt; <a class="struct" href="../prelude/struct.UniquePtr.html" title="struct autocxx::prelude::UniquePtr">UniquePtr</a>&lt;CppPeer&gt; <a href="#" class="tooltip" data-notable-ty="UniquePtr&lt;CppPeer&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Creates a new instance of this subclass. This instance is owned by the
returned <a href="../prelude/struct.UniquePtr.html" title="struct autocxx::prelude::UniquePtr"><code>cxx::UniquePtr</code></a> and thus would typically be returned immediately
to C++ such that it can be owned on the C++ side.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new_rust_owned" class="method"><a class="src rightside" href="../../src/autocxx/subclass.rs.html#312-318">Source</a><h4 class="code-header">fn <a href="#method.new_rust_owned" class="fn">new_rust_owned</a>(me: Self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/rc/struct.Rc.html" title="struct alloc::rc::Rc">Rc</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.85.0/core/cell/struct.RefCell.html" title="struct core::cell::RefCell">RefCell</a>&lt;Self&gt;&gt;</h4></section></summary><div class="docblock"><p>Creates a new instance of this subclass. This instance is not owned
by C++, and therefore will be deleted when it goes out of scope in
Rust.</p>
</div></details></div><h2 id="dyn-compatibility" class="section-header">Dyn Compatibility<a href="#dyn-compatibility" class="anchor">§</a></h2><div class="dyn-compatibility-info"><p>This trait is <b>not</b> <a href="https://doc.rust-lang.org/1.85.0/reference/items/traits.html#object-safety">dyn compatible</a>.</p><p><i>In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.</i></p></div><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"></div><script src="../../trait.impl/autocxx/subclass/trait.CppSubclass.js" async></script><script type="text/json" id="notable-traits-data">{"UniquePtr<CppPeer>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../prelude/struct.UniquePtr.html\" title=\"struct autocxx::prelude::UniquePtr\">UniquePtr</a>&lt;T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"../prelude/struct.UniquePtr.html\" title=\"struct autocxx::prelude::UniquePtr\">UniquePtr</a>&lt;T&gt;<div class=\"where\">where\n    <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/pin/struct.Pin.html\" title=\"struct core::pin::Pin\">Pin</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;'a mut T</a>&gt;: for&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a>,\n    T: <a class=\"trait\" href=\"../../cxx/unique_ptr/trait.UniquePtrTarget.html\" title=\"trait cxx::unique_ptr::UniquePtrTarget\">UniquePtrTarget</a>,</div></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for <a class=\"struct\" href=\"../prelude/struct.UniquePtr.html\" title=\"struct autocxx::prelude::UniquePtr\">UniquePtr</a>&lt;T&gt;<div class=\"where\">where\n    <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/pin/struct.Pin.html\" title=\"struct core::pin::Pin\">Pin</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;'a mut T</a>&gt;: for&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a>,\n    T: <a class=\"trait\" href=\"../../cxx/unique_ptr/trait.UniquePtrTarget.html\" title=\"trait cxx::unique_ptr::UniquePtrTarget\">UniquePtrTarget</a>,</div></div>"}</script></section></div></main></body></html>