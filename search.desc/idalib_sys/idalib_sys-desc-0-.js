searchState.loadedDescShard("idalib_sys", 0, "Synthesized copy constructor.\nSynthesized destructor.\n&lt; end_ea excluded\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSynthesized move constructor.\n\\file lines.hpp\n&lt; start_ea included\nAppend to an indented comment. Creates a new comment if …\nSet an indented comment. \\param ea      linear address …\nGet entry point address by its ordinal \\param ord  ordinal …\nGet ordinal number of an entry point. \\param idx  internal …\nGet number of entry points\n&lt; current architecture is not supported\n&lt; bad block found\n&lt; could not determine call arguments\n&lt; function frame is wrong\n&lt; inconsistent database information\n&lt; bad input ranges\n&lt; positive sp value has been found\n&lt; 16-bit functions cannot be decompiled\n&lt; no error, switch to new block\n&lt; already decompiling a function\n&lt; decompilation has been cancelled\n&lt; cloud: %s\n&lt; too complex function\n&lt; bad instruction in the delay slot\n&lt; exception analysis failed\n&lt; special segments cannot be decompiled\n&lt; far memory model is supported only for pc\n&lt; too big function\n&lt; stack frame is too big\n&lt; cannot convert to microcode\n&lt; internal error\n&lt; no license available\n&lt; internal code: redo last loop (never reported)\n&lt; local variable allocation failed\n&lt; not enough memory\n&lt; ok\n&lt; only 32-bit functions can be decompiled for the current …\n&lt; only 64-bit functions can be decompiled for the current …\n&lt; variables would overlap: %s\n&lt; partially initialized variable %s\n&lt; prolog analysis failed\n&lt; max recursion depth reached during lvar allocation\n&lt; redecompilation has been requested\n&lt; wrong basic type sizes in compiler settings\n&lt; no error, stop the analysis\n&lt; wrong switch idiom\n&lt; undefined type %s (currently unused error code)\n&lt; realcvt: illegal real data for load (IEEE data not …\n&lt; asctoreal: illegal input string\n&lt; realcvt: not supported format for current .idp\n&lt; floating overflow or underflow\n&lt; eetol*: integer overflow\n&lt; no error\n&lt; realcvt: number too big (small) for store (mem NOT …\n&lt; ediv: divide by 0\nReimplementation of the string class from STL. Only the …\nGet number of address bits\nGet number of address bytes\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nHas SP-analysis been performed?\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nThis class manages the offset and size of a value that …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nFunction argument\nFunction argument list\n\\name Byte size Number of 8bit bytes required to hold one …\nSmart pointer to objects derived from ::qrefcnt_obj_t\nautocxx bindings couldn’t be generated: This item …\nSet #start_ea, #end_ea to 0\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\n\\name Segment flag: ORG directive See #SFL_COMORG @{\nCompare two range_t instances, based on the start_ea\nIs ‘ea’ in the address range?\nIs every ea in ‘r’ also in this range_t?\nSynthesized copy constructor.\nSynthesized copy constructor.\nSynthesized copy constructor.\nSynthesized copy constructor.\nConstructor\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nCODE xref types\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nHelper function to get the delay slot instruction\nautocxx bindings couldn’t be generated: This item relies …\nDoes function return?\n&lt; Informational &lt; (a derived java class references its base\n&lt; Offset &lt; The reference uses ‘offset’ of data &lt; …\n&lt; Read access\n&lt; Reference to enum member (symbolic constant)\n&lt; Text (for forced operands only) &lt; Name of data is used …\n&lt; Unknown – for compatibility with old &lt; versions. …\n&lt; Write access\nDATA xref types\nSynthesized destructor.\nIs the size of the range_t &lt;= 0?\nautocxx bindings couldn’t be generated: This item relies …\n&lt; end_ea excluded\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This function …\nautocxx bindings couldn’t be generated: This item relies …\nEnsure that the range_t includes ‘ea’\nautocxx bindings couldn’t be generated: This item relies …\n&lt; AIX ar library\n&lt; Linux a.out (AOUT)\n&lt; ar library\n&lt; Binary File\n&lt; Common Object File Format (COFF)\n&lt; MS DOS COM File\n&lt; MS DOS COM File\n&lt; MS DOS Driver\n&lt; Executable and Linkable Format (ELF)\n&lt; MS DOS EXE File\n&lt; MS DOS EXE File\n&lt; Intel Hex Object File\n&lt; Linear Executable (LE)\n&lt; file is loaded using LOADER DLL\n&lt; Linear Executable (LX)\n&lt; Mac OS X Mach-O\n&lt; Mediatek Firmware Image\n&lt; MOS Technology Hex Object File\n&lt; Netware Loadable Module (NLM)\n&lt; Object Module Format\n&lt; Library of OMF Modules\n&lt; Portable Executable (PE)\n&lt; PalmPilot program file\n&lt; Sony Playstation PSX object file\n&lt; Motorola SREC (S-record)\n&lt; Watcom DOS32 Extender (W32RUN)\n&lt; New Executable (NE)\n&lt; ZIP file (this file is never loaded to IDA database)\nFlow chart block types\n&lt; conditional return block\n&lt; external noreturn block (does not belong to the function)\n&lt; block passes execution past the function end\n&lt; external normal block\n&lt; block ends with indirect jump\n&lt; noreturn block\n&lt; normal block\n&lt; return block\nKnown input file formats (kept in \\inf{filetype}):\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nGet first xref from the given address (store in #to)\nGet xref to given address (store in #from)\n&lt; Call Far &lt; This xref creates a function at the &lt; …\n&lt; Call Near &lt; This xref creates a function at the &lt; …\n&lt; Ordinary flow: used to specify execution &lt; flow to the …\n&lt; Jump Far\n&lt; Jump Near\n&lt; unknown – for compatibility with old &lt; versions. …\n&lt; User specified (obsolete)\n\\defgroup REAL_ERROR_ Floating point/IEEE Conversion codes …\n\\file ieee.h\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n&lt; the referencing address - filled by first_to(),next_to()\nautocxx bindings couldn’t be generated: This item relies …\nA function is a set of continuous ranges of addresses with …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nGet the instruction features (combination of \\ref CF_)\nGet the instruction name\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nGet default segment bitness \\retval 2  #PR_DEFSEG64 …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\n@}\nautocxx bindings couldn’t be generated: This item relies …\nGet register information - useful for registers like al, …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nGet the stack variable scaling factor. Useful for …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nException object: decompiler failure information\nautocxx bindings couldn’t be generated: This item …\nAssign the range_t to the intersection between the range_t …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs a 16-bit segment?\nIs a 32-bit segment?\nIs a 64-bit segment?\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nDoes the given value specify a valid instruction for this …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\n\\name Segment flag: debugger segment See #SFL_DEBUG @{\nEphemeral segments are not analyzed automatically (no …\nIs a far function?\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This function …\n\\name Segment flag: header segment See #SFL_HEADER @{\n\\name Segment flag: hide segment type See #SFL_HIDETYPE @{\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\n\\name Segment flag: loader segment See #SFL_LOADER @{\nautocxx bindings couldn’t be generated: This function …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\n\\name Segment flag: hidden See #SFL_HIDDEN @{\n&lt; is code reference (::cref_t)? &lt; otherwise it is a data …\nautocxx bindings couldn’t be generated: Problem handling …\nHelper class to lock a function pointer so it stays valid\nHelper class to lock a segment pointer so it stays valid\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This function …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\n\\defgroup MERR_ Microcode error codes @{\nSynthesized move constructor.\nSynthesized move constructor.\nSynthesized move constructor.\nSynthesized move constructor.\nautocxx bindings couldn’t be generated: This item relies …\nNeeds prolog analysis?\nConstructor\nSynthesized default constructor.\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item …\n\\file gdl.hpp\n&lt; Memory Ref [Base Reg + Index Reg + Displacement].\n&lt; Immediate Far Address  (CODE).\n&lt; processor specific type.\n&lt; processor specific type.\n&lt; processor specific type.\n&lt; processor specific type.\n&lt; processor specific type.\n&lt; processor specific type. &lt; (there can be more processor …\n&lt; Immediate Value.\n&lt; Direct Memory Reference  (DATA).\n&lt; Immediate Near Address (CODE).\n&lt; Memory Ref [Base Reg + Index Reg].\n&lt; General Register (al,ax,es,ds…).\n&lt; No Operand.\n\\name Segment flag: orgbase See #SFL_OBOK @{\nautocxx bindings couldn’t be generated: This item relies …\n\\defgroup operands Operands Work with instruction operands\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nIs there an ea in ‘r’ that is also in this range_t?\nA plugin is a module in the plugins subdirectory that can …\nPrint the range_t. \\param buf the output buffer \\param …\nautocxx bindings couldn’t be generated: This item relies …\nDescribes a processor module (IDP). An IDP file may have …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nInformation about a basic block of a \\ref qflow_chart_t\nA flow chart for a function, or a set of address ranges\nSmart pointer to objects derived from ::qrefcnt_obj_t\nReimplementation of the string class from STL. Only the …\n\\file lines.hpp\nDescribes a program segment\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nGet #end_ea - #start_ea\nGet size of long double\n&lt; start_ea included\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nPrimary mechanism for managing type information\n&lt; the referenced address - filled by first_from(), …\nautocxx bindings couldn’t be generated: This item relies …\n&lt; type of the last returned reference (::cref_t &amp; ::dref_t)\nautocxx bindings couldn’t be generated: This item relies …\nUpdate segment information. You must call this function …\nautocxx bindings couldn’t be generated: This item …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\n&lt; is user defined xref? otherwise defined by ida\nautocxx bindings couldn’t be generated: This item relies …\nHelper class to convert cfunc_t into text.\nautocxx bindings couldn’t be generated: This item relies …\nautocxx bindings couldn’t be generated: This item relies …\nStructure to enumerate all xrefs. This structure provides …\n&lt; current architecture is not supported\n&lt; bad block found\n&lt; could not determine call arguments\n&lt; function frame is wrong\n&lt; inconsistent database information\n&lt; bad input ranges\n&lt; positive sp value has been found\n&lt; 16-bit functions cannot be decompiled\n&lt; no error, switch to new block\n&lt; already decompiling a function\n&lt; decompilation has been cancelled\n&lt; cloud: %s\n&lt; too complex function\n&lt; bad instruction in the delay slot\n&lt; exception analysis failed\n&lt; special segments cannot be decompiled\n&lt; far memory model is supported only for pc\n&lt; too big function\n&lt; stack frame is too big\n&lt; cannot convert to microcode\n&lt; internal error\n&lt; no license available\n&lt; internal code: redo last loop (never reported)\n&lt; local variable allocation failed\n&lt; not enough memory\n&lt; ok\n&lt; only 32-bit functions can be decompiled for the current …\n&lt; only 64-bit functions can be decompiled for the current …\n&lt; variables would overlap: %s\n&lt; partially initialized variable %s\n&lt; prolog analysis failed\n&lt; max recursion depth reached during lvar allocation\n&lt; redecompilation has been requested\n&lt; wrong basic type sizes in compiler settings\n&lt; no error, stop the analysis\n&lt; wrong switch idiom\n&lt; undefined type %s (currently unused error code)\n&lt; realcvt: illegal real data for load (IEEE data not …\n&lt; asctoreal: illegal input string\n&lt; realcvt: not supported format for current .idp\n&lt; floating overflow or underflow\n&lt; eetol*: integer overflow\n&lt; no error\n&lt; realcvt: number too big (small) for store (mem NOT …\n&lt; ediv: divide by 0\nSynthesized copy constructor.\nSynthesized move constructor.\nAppend to an indented comment. Creates a new comment if …\n&lt; list of arguments (indexes into vars)\nProcess everything in the queues and return true. \\return …\nThis class manages the offset and size of a value that …\nSynthesized copy constructor.\nSynthesized move constructor.\n&lt; function body, must be a block\n&lt; map of instruction boundaries. use \\ref get_boundaries\nRebuild the string list.\nCalculate target of a thunk function. \\param pfn   pointer …\nFunction argument\nSynthesized destructor.\nFunction argument list\nSynthesized destructor.\nClear the string list.\n\\brief Close the current database \\param save boolean …\nCODE xref types\nCurrent segment base paragraph. Initialized by the kernel.\nAnalyze the specified address and fill ‘out’. This …\n&lt; Informational &lt; (a derived java class references its base\n&lt; Offset &lt; The reference uses ‘offset’ of data &lt; …\n&lt; Read access\n&lt; Reference to enum member (symbolic constant)\n&lt; Text (for forced operands only) &lt; Name of data is used …\n&lt; Unknown – for compatibility with old &lt; versions. …\n&lt; Write access\nDATA xref types\nLinear address of the instruction. Initialized by the …\n&lt; ea-&gt;insn map. use \\ref get_eamap\n\\brief Enable console messages \\param enable  flag to …\n&lt; end_ea excluded\n&lt; function entry address\n&lt; \\ref EXFL_\n&lt; AIX ar library\n&lt; Linux a.out (AOUT)\n&lt; ar library\n&lt; Binary File\n&lt; Common Object File Format (COFF)\n&lt; MS DOS COM File\n&lt; MS DOS COM File\n&lt; MS DOS Driver\n&lt; Executable and Linkable Format (ELF)\n&lt; MS DOS EXE File\n&lt; MS DOS EXE File\n&lt; Intel Hex Object File\n&lt; Linear Executable (LE)\n&lt; file is loaded using LOADER DLL\n&lt; Linear Executable (LX)\n&lt; Mac OS X Mach-O\n&lt; Mediatek Firmware Image\n&lt; MOS Technology Hex Object File\n&lt; Netware Loadable Module (NLM)\n&lt; Object Module Format\n&lt; Library of OMF Modules\n&lt; Portable Executable (PE)\n&lt; PalmPilot program file\n&lt; Sony Playstation PSX object file\n&lt; Motorola SREC (S-record)\n&lt; Watcom DOS32 Extender (W32RUN)\n&lt; New Executable (NE)\n&lt; ZIP file (this file is never loaded to IDA database)\nFlow chart block types\n&lt; conditional return block\n&lt; external noreturn block (does not belong to the function)\n&lt; block passes execution past the function end\n&lt; external normal block\n&lt; block ends with indirect jump\n&lt; noreturn block\n&lt; normal block\n&lt; return block\nKnown input file formats (kept in \\inf{filetype}):\nFind a user-defined plugin and optionally load it. \\param …\n&lt; Call Far &lt; This xref creates a function at the &lt; …\n&lt; Call Near &lt; This xref creates a function at the &lt; …\n&lt; Ordinary flow: used to specify execution &lt; flow to the …\n&lt; Jump Far\n&lt; Jump Near\n&lt; unknown – for compatibility with old &lt; versions. …\n&lt; User specified (obsolete)\n&lt; \\ref INSN_\n\\defgroup REAL_ERROR_ Floating point/IEEE Conversion codes …\n\\file ieee.h\nSynthesized copy constructor.\nSynthesized move constructor.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n&lt; the referencing address - filled by first_to(),next_to()\nA function is a set of continuous ranges of addresses with …\nSynthesized copy constructor.\nSynthesized move constructor.\nSynthesized destructor.\ngdl graph interface - includes only functions required to …\nGet entry point address by its ordinal \\param ord  ordinal …\nGet ordinal number of an entry point. \\param idx  internal …\nGet number of entry points\nGet pointer to function structure by address. \\param ea  …\nGet ordinal number of a function. \\param ea  any address …\nGet total number of functions in the program\nGet register information - useful for registers like al, …\nGet pointer to segment by its name. If there are several …\nGet number of segments\nGet number of elements in the string list. The list will …\nGet pointer to function structure by number. \\param n  …\nGet pointer to segment by its number. \\warning Obsoleted …\nGet pointer to segment by linear address. \\param ea  …\nDoes ‘ea’ have references from outside of ‘pfn’?\n&lt; number of lines in the declaration area\nException object: decompiler failure information\nSynthesized destructor.\nCheck that your plugin is compatible with hex-rays …\n&lt; processor dependent field\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nVirtual address of the instruction (address within the …\nIf the instruction at ‘ea’ looks like an alignment …\nIs the instruction the end of a basic block?\nIs the instruction a “call”?\nIs the instruction an indirect jump?\n@}\n&lt; is code reference (::cref_t)? &lt; otherwise it is a data …\nInternal code of instruction (only for canonical insns - …\nHelper class to lock a function pointer so it stays valid\nSynthesized copy constructor.\nHelper class to lock a segment pointer so it stays valid\nSynthesized copy constructor.\n\\brief Generate .sig and .pat files for the current …\n&lt; maturity level\n&lt; underlying microcode\n\\defgroup MERR_ Microcode error codes @{\nGet start of next defined item. \\param ea     begin search …\n\\file gdl.hpp\nSynthesized copy constructor.\nSynthesized move constructor.\n&lt; user-defined number formats.\n\\brief Open the database specified in file_path argument …\n&lt; array of operands\nA plugin is a module in the plugins subdirectory that can …\nSynthesized copy constructor.\nSynthesized move constructor.\nSynthesized destructor.\nGet start of previous defined item. \\param ea     begin …\nDescribes a processor module (IDP). An IDP file may have …\nGet the instruction features (combination of \\ref CF_)\nGet the instruction name\nDoes the given value specify a valid instruction for this …\nSynthesized destructor.\nInformation about a basic block of a \\ref qflow_chart_t\nSynthesized destructor.\nA flow chart for a function, or a set of address ranges\n\\file lines.hpp\nSynthesized copy constructor.\nSynthesized move constructor.\nSynthesized destructor.\n&lt; reference count to this object. use cfuncptr_t\nRun a loaded plugin with the specified argument. \\param …\nDescribes a program segment\nConstructor\nSynthesized copy constructor.\nSynthesized move constructor.\nSynthesized destructor.\n&lt; processor dependent field\nSet an indented comment. \\param ea      linear address …\n\\brief Set screen ea, let the user specify the current …\nSize of instruction in bytes. The analyzer should put here …\n&lt; start_ea included\n&lt; current cfunc_t state. see \\ref CFS_\n&lt; decompilation output: function text. use \\ref …\nStop working with hex-rays decompiler.\nPrimary mechanism for managing type information\nConstructor\n&lt; the referenced address - filled by first_from(), …\n&lt; vector of pointers to citem_t objects (nodes …\n&lt; type of the last returned reference (::cref_t &amp; ::dref_t)\n&lt; expression type. must be carefully maintained\n&lt; is user defined xref? otherwise defined by ida\n&lt; user-defined comments.\n&lt; user-defined item flags \\ref CIT_\n&lt; user-defined labels.\n&lt; user-defined union field selections.\nHelper class to convert cfunc_t into text.\nStructure to enumerate all xrefs. This structure provides …\n\\name Helper functions Should not be called directly! @{\nSynthesized default constructor.\nSynthesized copy constructor.\nSynthesized move constructor.\nSynthesized destructor.\n&lt; list of arguments (indexes into vars)\n&lt; function body, must be a block\n&lt; map of instruction boundaries. use \\ref get_boundaries\n&lt; memory model and calling convention (see \\ref CM_)\n&lt; default alignment for structures\n&lt; ea-&gt;insn map. use \\ref get_eamap\n&lt; end_ea excluded\n&lt; function entry address\n&lt; AIX ar library\n&lt; Linux a.out (AOUT)\n&lt; ar library\n&lt; Binary File\n&lt; Common Object File Format (COFF)\n&lt; MS DOS COM File\n&lt; MS DOS COM File\n&lt; MS DOS Driver\n&lt; Executable and Linkable Format (ELF)\n&lt; MS DOS EXE File\n&lt; MS DOS EXE File\n&lt; Intel Hex Object File\n&lt; Linear Executable (LE)\n&lt; file is loaded using LOADER DLL\n&lt; Linear Executable (LX)\n&lt; Mac OS X Mach-O\n&lt; Mediatek Firmware Image\n&lt; MOS Technology Hex Object File\n&lt; Netware Loadable Module (NLM)\n&lt; Object Module Format\n&lt; Library of OMF Modules\n&lt; Portable Executable (PE)\n&lt; PalmPilot program file\n&lt; Sony Playstation PSX object file\n&lt; Motorola SREC (S-record)\n&lt; Watcom DOS32 Extender (W32RUN)\n&lt; New Executable (NE)\n&lt; ZIP file (this file is never loaded to IDA database)\nReturns the argument unchanged.\n&lt; number of lines in the declaration area\n&lt; compiler id (see \\ref COMP_)\nCalls <code>U::from(self)</code>.\n&lt; maturity level\n&lt; underlying microcode\n&lt; user-defined number formats.\n&lt; reference count to this object. use cfuncptr_t\n&lt; sizeof(bool)\n&lt; sizeof(enum)\n&lt; sizeof(int)\n&lt; long\n&lt; longdouble (if different from \\ph{tbyte_size})\n&lt; longlong\n&lt; short\n&lt; start_ea included\n&lt; current cfunc_t state. see \\ref CFS_\n&lt; decompilation output: function text. use \\ref …\n&lt; vector of pointers to citem_t objects (nodes …\n&lt; user-defined comments.\n&lt; user-defined item flags \\ref CIT_\n&lt; user-defined labels.\n&lt; user-defined union field selections.\nCalculate target of a thunk function. \\param pfn   pointer …\nSynthesized copy constructor.\nSynthesized copy constructor.\nSynthesized destructor.\nSynthesized destructor.\nFlow chart block types\n&lt; conditional return block\n&lt; external noreturn block (does not belong to the function)\n&lt; block passes execution past the function end\n&lt; external normal block\n&lt; block ends with indirect jump\n&lt; noreturn block\n&lt; normal block\n&lt; return block\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nA function is a set of continuous ranges of addresses with …\ngdl graph interface - includes only functions required to …\nGet pointer to function structure by address. \\param ea  …\nGet ordinal number of a function. \\param ea  any address …\nGet total number of functions in the program\nGet pointer to function structure by number. \\param n  …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHelper class to lock a function pointer so it stays valid\nSynthesized move constructor.\nautocxx bindings couldn’t be generated: This method is …\nInformation about a basic block of a \\ref qflow_chart_t\nA flow chart for a function, or a set of address ranges\n&lt; list of arguments (indexes into vars)\n&lt; function body, must be a block\n&lt; map of instruction boundaries. use \\ref get_boundaries\nFunction argument\nFunction argument list\n&lt; Switch cases: values and instructions\n&lt; “catch all”, if present, must be the last element. &lt; …\nCompound statement (curly braces)\nCtree item: expression. Depending on the exact expression …\nDecompiled function. Decompilation result is kept here.\nSmart pointer to objects derived from ::qrefcnt_obj_t\nCtree item: statement. Depending on the exact statement …\nBasic ctree item. This is an abstract class (but we don’…\nSwitch statement\nThrow statement\nC++ Try statement. This structure is also used to …\nSynthesized destructor.\nSynthesized destructor.\n&lt; address that corresponds to the item. may be BADADDR\n&lt; ea-&gt;insn map. use \\ref get_eamap\n&lt; function entry address\n&lt; \\ref EXFL_\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n&lt; number of lines in the declaration area\n&lt; an index in cfunc_t::treeitems. &lt; meaningful only after …\nCheck that your plugin is compatible with hex-rays …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs C++ wind statement? (not part of the C++ language) MSVC …\n&lt; label number. -1 means no label. items of the expression …\n&lt; maturity level\n&lt; underlying microcode\n&lt; Maximal switch value and number format\n&lt; new state number (internal, MSVC related)\n&lt; user-defined number formats.\n&lt; old state number (internal, MSVC related)\n&lt; item type\n&lt; reference count to this object. use cfuncptr_t\n&lt; current cfunc_t state. see \\ref CFS_\n&lt; decompilation output: function text. use \\ref …\nStop working with hex-rays decompiler.\n&lt; vector of pointers to citem_t objects (nodes …\n&lt; expression type. must be carefully maintained\n&lt; user-defined comments.\n&lt; user-defined item flags \\ref CIT_\n&lt; user-defined labels.\n&lt; user-defined union field selections.\nReimplementation of the string class from STL. Only the …\n&lt; its value\n&lt; argument list (used for \\ref cot_call)\n&lt; aliased_memory+restricted_memory=ALLMEM\n&lt; -1 - don’t align. &lt; 0  - align automatically. &lt; else …\n&lt; FRB_TABFORM, &lt; AP_SIGNED is ignored, use FRB_SIGNED …\n&lt; input arguments (indexes into ‘vars’)\n&lt; list of arguments (indexes into vars)\n&lt; ida argloc\nDescribes an argument location. A typical argument is …\nSpecifies the location type of a function argument or a …\nSubsection of an argument location\nReimplementation of vector class from STL. Only the most …\n&lt; call arguments\n&lt; number of bytes purged from the stack &lt; upon returning\n\\name Array representation @{ Describes how to display an …\n&lt; base of reference (may be BADADDR)\n&lt; line background color\n&lt; pointer to bitmap\nBit set class. See https://en.wikipedia.org/wiki/Bit_array\n&lt; double linked list of blocks\n&lt; function body, must be a block\n&lt; map of instruction boundaries. use \\ref get_boundaries\nVector of bytes (use for dynamic memory)\n&lt; sp value at call insn\n&lt; address of the called function, if known\nFunction argument list\n&lt; Switch cases: values and instructions\nVector of case values - see calc_switch_cases()\n&lt; details of asm-statement\nasm statement\nCatch expression\nReimplementation of vector class from STL. Only the most …\n&lt; “catch all”, if present, must be the last element. &lt; …\n&lt; details of block-statement\nCompound statement (curly braces)\n&lt; calling convention\n&lt; calling convention\nSwitch case. Usually cinsn_t is a block\nVector of switch cases\nCatch clause: “catch ( type obj )”\nReimplementation of vector class from STL. Only the most …\n&lt; FRB_CUSTOM\n&lt; details of do-statement\nDo-loop\nStatement with an expression. This is a base class for …\n&lt; details of expression-statement\nCtree item: expression. Depending on the exact expression …\nFind the pointer operand. This function returns the …\nCheck if the expression if aliasable. Simple registers and …\nDoes the PARENT need the expression value\nDoes the expression look like a boolean expression? In …\n&lt; details of for-statement\nFor-loop\nDecompiled function. Decompilation result is kept here.\n&lt; details of goto-statement\nGoto statement\n&lt; details of if-statement\nIf statement\nLinked list Note: linked list is not movable!\nCtree item: statement. Depending on the exact statement …\nVector of pointers to statements.\nCtree item comment. For each comment we remember its body …\nGeneric ctree item locator. It can be used for …\nVector of parents\nBasic ctree item. This is an abstract class (but we don’…\nBase class for loop statements\n&lt; member comment\n&lt; variable comment string\nAn immediate number\n&lt; user defined function color\n&lt; line prefix color\n@}\n&lt; registers converted into stack arguments, should not be …\n&lt; details of return-statement\nReturn statement\n&lt; details of switch-statement\nSwitch statement\n&lt; details of throw-statement\nThrow statement\nCtree maturity level. The level will increase as we switch …\n&lt; just generated\n&lt; added necessary casts\n&lt; corrected pointer arithmetic\n&lt; ready-to-use\n&lt; nicefied expressions\n&lt; applied first wave of transformations\n&lt; applied second wave of transformations\n&lt; applied third wave of transformations\n&lt; does not exist\n&lt; details of try-statement\nC++ Try statement. This structure is also used to …\nCtree item code. At the beginning of this list there are …\n&lt; asm-statement\n&lt; block-statement: { … }\n&lt; break-statement\n&lt; continue-statement\n&lt; do-statement\n&lt; instruction types start here\n&lt; expression-statement: expr;\n&lt; for-statement\n&lt; goto-statement\n&lt; if-statement\n&lt; return-statement\n&lt; switch-statement\n&lt; C++ throw-statement\n&lt; C++ try-statement\n&lt; while-statement\n&lt; x + y\n&lt; x = y\n&lt; x += y\n&lt; x &amp;= y\n&lt; x |= y\n&lt; x *= y\n&lt; x /= y signed\n&lt; x &lt;&lt;= y\n&lt; x %= y signed\n&lt; x &gt;&gt;= y signed\n&lt; x -= y\n&lt; x /= y unsigned\n&lt; x %= y unsigned\n&lt; x &gt;&gt;= y unsigned\n&lt; x ^= y\n&lt; x &amp; y\n&lt; ~x\n&lt; x | y\n&lt; x(…)\n&lt; (type)x\n&lt; x, y\n&lt; x == y int or fpu (see EXFL_FPOP)\n&lt; x + y fp\n&lt; x / y fp\n&lt; x * y fp\n&lt; -x fp\n&lt; fpc\n&lt; x - y fp\n&lt; arbitrary name\n&lt; x[y]\n&lt; instruction in expression, internal representation only\n&lt; x &amp;&amp; y\n&lt; !x\n&lt; x || y\n&lt; x-&gt;m, access size in ‘ptrsize’\n&lt; x.m\n&lt; x * y\n&lt; x != y int or fpu (see EXFL_FPOP)\n&lt; -x\n&lt; n\n&lt; obj_ea\n&lt; x–\n&lt; x++\n&lt; –x\n&lt; ++x\n&lt; *x, access size in ‘ptrsize’\n&lt; &amp;x\n&lt; x / y signed\n&lt; x &gt;= y signed or fpu (see EXFL_FPOP)\n&lt; x &gt;  y signed or fpu (see EXFL_FPOP)\n&lt; x &lt;&lt; y\n&lt; sizeof(x)\n&lt; x &lt;= y signed or fpu (see EXFL_FPOP)\n&lt; x &lt;  y signed or fpu (see EXFL_FPOP)\n&lt; x % y signed\n&lt; x &gt;&gt; y signed\n&lt; string constant (user representation)\n&lt; x - y\n&lt; x ? y : z\n&lt; arbitrary type\n&lt; x / y unsigned\n&lt; x &gt;= y unsigned\n&lt; x &gt;  y unsigned\n&lt; x &lt;= y unsigned\n&lt; x &lt;  y unsigned\n&lt; x % y unsigned\n&lt; x &gt;&gt; y unsigned\n&lt; v\n&lt; x ^ y\n&lt; details of while-statement\nWhile-loop\n&lt; destination operand\n&lt; data that is dead at the block entry\n&lt; registers defined by the function but never used. &lt; upon …\n&lt; first block defining the variable. &lt; 0 for args, -1 if …\n&lt; Definition address. Usually, this is the address &lt; of …\n&lt; FRB_STROFF\n&lt; max known divisor of the variable\n&lt; data that is defined but not used in the block\n&lt; data type id\n&lt; address where the argument was initialized. &lt; BADADDR …\n&lt; instruction address\n&lt; address of the original processor instruction\n&lt; Address where the warning occurred\n&lt; citem address\n&lt; address that corresponds to the item. may be BADADDR\n&lt; ea-&gt;insn map. use \\ref get_eamap\nReimplementation of vector class from STL. Only the most …\n&lt; effective field alignment (in bytes)\n&lt; end address &lt; note: we cannot rely on start/end addresses\n&lt; end_ea excluded\n&lt; function entry address\n&lt; during microcode generation holds ins.ea\n&lt; \\ref EXFL_\n&lt; Expression of the statement\n&lt; if not empty, type of the caught object. &lt; ideally, …\n&lt; field alignment (shift amount)\n&lt; data format ids\n&lt; is the function type final? (specified by the user)\n&lt; \\ref CVAR_\n&lt; FAI_…\n&lt; combination of \\ref FCI_… bits\n&lt; \\ref REFINFO_\n&lt; \\ref FUNC_\n&lt; ida flags, which describe number radix, enum, etc\n&lt; combination of \\ref MBL_ bits\n&lt; low 32bit of flags (for compatibility)\n&lt; Internal representation of the number\nFloating point constant. Used for mop_fn For more details, …\n&lt; used for \\ref cot_fnum\n&lt; frame pointer delta\n&lt; frame pointer delta. (usually 0, i.e. realBP==typicalBP) …\n\\file ieee.h\n&lt; netnode id of frame structure - see frame.hpp\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n&lt; size of saved registers range in the stack frame\n&lt; size of saved registers in frame. This range is &lt; …\n&lt; size of local stkvars range in the stack frame\n&lt; size of local variables part of frame in bytes. &lt; If …\n&lt; extended function attributes\n&lt; FTI_… constants for the current function\n&lt; Full stack size including incoming args\n&lt; cfunc_t to generate text for\nA function is a set of continuous ranges of addresses with …\nattributes of a function entry chunk\nattributes of a function tail chunk\nFunction roles. They are used to calculate use/def lists …\n&lt; 3-way compare helper, returns -1/0/1\n&lt; 3-way compare helper, returns 0/1/2\n&lt; integer absolute value\n&lt; alloca() function\n&lt; [lock] bt\n&lt; [lock] btc\n&lt; [lock] btr\n&lt; [lock] bts\n&lt; bswap() function (any size)\n&lt; BUG() helper macro: never returns, causes exception\n&lt; carry flag after subtract with carry\n&lt; CONTAINING_RECORD() macro\n&lt; empty, does not do anything (maybe spoils regs)\n&lt; __fastfail()\n&lt; is_mul_ok\n&lt; memcpy(void *dst, const void *src, size_t count);\n&lt; memset(void *dst, uchar value, size_t count);\n&lt; memset32(void *dst, uint32 value, size_t count);\n&lt; memset64(void *dst, uint64 value, size_t count);\n&lt; overflow flag after subtract with carry\n&lt; present() function (used in patterns)\n&lt; __readeflags, __readcallersflags\n&lt; rotate left\n&lt; rotate right\n&lt; saturated_mul\n&lt; e.g. _mm_cmpgt_ss\n&lt; e.g. _mm_cmpgt_sd\n&lt; strcat(char *dst, const char *src);\n&lt; strcpy(char *dst, const char *src);\n&lt; strlen(const char *src);\n&lt; char *tail(const char *str);\n&lt; unknown function role\n&lt; va_arg() macro\n&lt; va_copy() function\n&lt; va_end() function\n&lt; va_start() function\n&lt; wchar_t *wcscat(wchar_t *dst, const wchar_t *src)\n&lt; wchar_t *wcscpy(wchar_t *dst, const wchar_t *src);\n&lt; size_t wcslen(const wchar_t *s)\n&lt; wchar_t *wmemcpy(wchar_t *dst, const wchar_t *src, …\n&lt; wchar_t *wmemset(wchar_t *dst, wchar_t wc, size_t n)\n&lt; stkvars that hold .got offsets. considered to be …\n&lt; number of lines in the declaration area\n&lt; number of header lines (prototype+typedef+lvars) &lt; valid …\n&lt; pointer to the first instruction of the block\n&lt; helper name (used for \\ref cot_helper)\nWarning instances\nReimplementation of vector class from STL. Only the most …\n&lt; highest bit+1 (multiply of bitset_width)\n&lt; high operand\n&lt; Warning id\n&lt; MBA_SPLINFO &amp;&amp; final_type: info in ida format\n&lt; function type as retrieved from the database\n&lt; index into mba-&gt;vars\n&lt; index into lvars_t\n&lt; Else-branch of the if-statement. May be nullptr.\n&lt; offset of the first stack argument; &lt; after …\n&lt; an index in cfunc_t::treeitems. &lt; meaningful only after …\n&lt; Initialization expression\n&lt; an embedded statement, they are prohibited &lt; at the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReimplementation of vector class from STL. Only the most …\n&lt; combination of \\ref IPROP_ bits\nIs C++ wind statement? (not part of the C++ language) MSVC …\nComment item preciser. Item preciser is used to assign …\n&lt; , (64 entries are reserved for 64 call arguments)\n&lt; __asm-line\n&lt; opening block comment. this comment is printed before …\n&lt; closing block comment.\n&lt; )\n&lt; bit for switch cases\n&lt; : (label)\n&lt; {\n&lt; }\n&lt; do-line\n&lt; else-line\n&lt; nothing\n&lt; semicolon\n&lt; if this bit is set too, then we have a negative case …\n&lt; C++ try statement\n&lt; Then-branch of the if-statement\nReimplementation of vector class from STL. Only the most …\n&lt; one symbol keys are reserved to be used by the kernel &lt; …\n&lt; left operand\n&lt; name of the function or pattern (colored)\n&lt; label number. -1 means no label. items of the expression …\n&lt; Target label number\n&lt; internal: last printed character\n&lt; line text\n&lt; number of items on a line\n&lt; number of local labels\n&lt; local labels array. &lt; this array shouldn’t be modified …\n&lt; Variable location.\n&lt; low operand\nLocal variable locator. Local variables are located using …\nReference to a local variable. Used by mop_l\nDefinition of a local variable (register or stack) #var …\nVector of local variables\n&lt; member offset (used for \\ref cot_memptr, \\ref cot_memref)\n&lt; current maturity level\n&lt; maturity level\n&lt; maximal sp value in the block (0…stacksize)\n&lt; data that may  be defined by the block\n&lt; data that may  be used by the block\nPointer to the parent mba_t object. Some operations may …\n&lt; underlying microcode\nPointer to the parent mba_t object. Since we need to …\nPointer to the parent mba_t object. We need it in order to …\n&lt; the parent micro block array\n&lt; pointer to the underlying micro array\nMicrocode maturity levels\n&lt; detected call arguments. see also hxe_calls_done\n&lt; generated microcode\n&lt; performed the first pass of global optimization\n&lt; most global optimization passes are done\n&lt; completed all global optimization. microcode is fixed …\n&lt; local optimization of each basic block is complete. &lt; …\n&lt; allocated local variables\n&lt; preoptimized pass is complete\n&lt; microcode does not exist\nRanges to decompile. Either a function or an explicit …\nArray of micro blocks representing microcode for a …\nMicrocode of one basic block. All blocks are part of a …\nBasic block types\n&lt; does not have successors (tail is a noret function)\n&lt; passes execution to one block (regular or goto block)\n&lt; passes execution to two blocks (conditional jump)\n&lt; unknown block type\n&lt; passes execution to many blocks (switch idiom)\n&lt; stops execution regularly (must be the last block)\n&lt; external block (out of function address)\nA call argument\nReimplementation of vector class from STL. Only the most …\nInformation about a call\nList of switch cases and targets\n&lt; The lowest stack argument location whose address was …\n&lt; the same for arguments\n&lt; lowest stack location accessible with indirect &lt; …\nMicroinstruction class #insn\n&lt; The lowest stack location whose address was taken\n&lt; address with lowest minstkref (for debugging)\nAn integer constant. Used for mop_n We support 64-bit …\nAddress of an operand (mop_l, mop_v, mop_S, mop_r)\nPair of operands\nA microinstruction operand. This is the smallest building …\nThe following union holds additional details about the …\nInstruction operand types\nReimplementation of vector class from STL. Only the most …\n&lt; data that must be defined by the block\n&lt; data that must be used by the block\n&lt; Maximal switch value and number format\n&lt; used for \\ref cot_num\n&lt; member name\n&lt; variable name. &lt; use mba_t::set_nice_lvar_name() and &lt; …\nUsually scattered operands are created from a function …\n&lt; formal argument name\n&lt; natural order of blocks\n&lt; Original size of the constant in bytes\n&lt; new state number (internal, MSVC related)\n&lt; next insn in doubly linked list. check also nexti()\n&lt; next block in the doubly linked list\n&lt; how to represent it\n&lt; global dead elimination may not delete references to …\n&lt; -1 - unknown\nNumber representation. This structure holds information …\n&lt; user-defined number formats.\n&lt; the caught object. if obj.op==cot_empty, no object. &lt; …\n&lt; used for \\ref cot_obj\n&lt; offset from the beginning of the argument\n&lt; displacement from the address pointed by the register\n&lt; offset from the beginning of the variable\nOffset to the stack variable from the bottom of the stack …\n&lt; member offset in bits\n&lt; old state number (internal, MSVC related)\n&lt; citem operation\n&lt; item type\n&lt; instruction opcode\nOperand locator. It is used to denote a particular operand …\n&lt; operand number in the instruction\n&lt; operand number: 0..UA_MAXOP\nOperand properties.\n&lt; original number size in bytes\n&lt; the address of the main function possessing this tail\n&lt; passthrough registers: registers that depend on input &lt; …\n&lt; function to decompile. if not null, then function mode.\n&lt; copy of func_t::flags\n&lt; number of SP change points\n&lt; array of SP change points. &lt; use …stkpnt…() …\n&lt; control flow graph: list of our predecessors &lt; use …\n&lt; prev insn in doubly linked list. check also previ()\n&lt; previous block in the doubly linked list\n&lt; properties: combination of NF_ bits (\\ref NF_)\n&lt; memory access size (used for \\ref cot_ptr, \\ref …\nLinked list Note: linked list is not movable!\nReimplementation of the string class from STL. Only the …\n&lt; number of basic blocks\nReimplementation of vector class from STL. Only the most …\n&lt; right operand\n\\file lines.hpp\n&lt; snippet mode: ranges to decompile. &lt; function mode: list …\nAn ordered set of non-overlapping address ranges\nCheck if the intended move_chunk() arguments are correct.\nSize in bytes\nSubtract the address range (from, from+size) and add the …\nReimplementation of vector class from STL. Only the most …\n&lt; reference count to this object. use cfuncptr_t\n&lt; array of referers (function start addresses). &lt; use …\nInformation about a reference\n&lt; number of referers\n&lt; how many bytes are accessed? (-1: none)\n&lt; register number\n&lt; register index (into \\varmem{ph,processor_t,reg_names})\nGet register number and size from register name\nRegister argument description. regargs are destroyed when …\n&lt; number of register arguments. &lt; During analysis IDA …\n&lt; unsorted array of register arguments. &lt; use …regarg……\nReimplementation of vector class from STL. Only the most …\n&lt; number of register variables (-1-not read in yet) &lt; use …\n&lt; array of register variables. &lt; this array is sorted by: …\n&lt; radix, refinfo, strpath, custom_id, strtype\n&lt; required maturity level\n&lt; return register(s) (e.g., AX, AX:DX, etc.) &lt; this vector …\n&lt; size of return address in the stack frame\n&lt; location of the returned value\n&lt; list of values returned by the function\n&lt; type of the returned value\n&lt; index of variable holding the return value &lt; -1 means …\n&lt; FRB_OFFSET\n&lt; function role\nRegister-relative argument location\nUsed to manage arguments that are described by multiple …\nScattered operand info. Used for mop_sc\n&lt; for enums: constant serial number\n&lt; block number\n&lt; size of shadow argument area\nMaintain basic information for a line in a custom view\n&lt; the number of bytes\n&lt; size in bits\nOperand size. Usually it is 1,2,4,8 or NOSIZE but for UDTs …\n&lt; register size\n&lt; number of solid args. &lt; there may be variadic args in …\n&lt; If sp&gt;0, the max positive sp value\n&lt; list of spoiled locations (includes return_regs)\n&lt; MBA_SPLINFO &amp;&amp; !final_type: info in vd format\n&lt; The maximal size of the function stack including &lt; bytes …\n&lt; start address\n&lt; start_ea included\n&lt; current cfunc_t state. see \\ref CFS_\n&lt; we treat memory as consisting of 6 parts &lt; see \\ref …\n&lt; Step expression\n&lt; first offset past stack arguments\n\\file funcs.hpp\nReference to a stack variable. Used for mop_S\n&lt; utf8 string constant, user representation (used for \\ref …\n&lt; FRB_STRLIT\nA collection of simple lines to populate a custom view. …\n&lt; control flow graph: list of our successors &lt; use nsucc() …\n&lt; decompilation output: function text. use \\ref …\nReimplementation of vector class from STL. Only the most …\nOperand type.\n&lt; TAH bits\n&lt; pointer to the last instruction of the block\n&lt; number of function tails\n&lt; array of tails, sorted by ea. &lt; use func_tail_iterator_t …\n&lt; reference target (#BADADDR-none)\n&lt; target block numbers\n&lt; offset from the target\n&lt; Fully formatted text of the warning\n&lt; variable type\nPrimary mechanism for managing type information\nSet or clear the ‘bitmask’ attribute of an enum. This …\n&lt; convert to bitmask if the outcome is nice and useful\n&lt; convert to ordinal enum\n&lt; convert to bitmask enum\n&lt; get bit buckets\n&lt; get type comment\n&lt; get final referenced name\n&lt; get referenced name\n&lt; get immediately next referenced name\n&lt; get the referenced name and apply regular expressions to …\n&lt; get repeatable type comment\n&lt; get type library\n&lt; get udt member functions\nVarious type properties (properties are 64-bit scalar …\n&lt; get type alias\n&lt; array: array element\n&lt; array: number of elements\n&lt; enum: is bitmask or regular enum \\ref …\n&lt; declared alignment\n&lt; enum: get enum type member by index\n&lt; enum: find enum type member by name\n&lt; enum: find enum type member by value/serial/bmask\n&lt; enum: get enum member tid\n&lt; enum: get number of enum members\n&lt; enum: get enum base type\n&lt; enum: get enum radix \\ref …\n&lt; enum: get enum value representation\n&lt; enum: get enum width \\ref enum_type_data_t::calc_nbytes()\n&lt; if array, skip possible arrays, return a non-array type\n&lt; get final (resolved) type ordinal\n&lt; if a forward declaration, return either …\n&lt; frame: get function address for the frame\n&lt; is from a subtil (not from main til)\n&lt; func: get type of function arg\n&lt; func: calling convention\n&lt; func: number of arguments\n&lt; func: get function return type\n&lt; has members of type “union”?\n&lt; has vftable?\n&lt; is anonymous struct/union?\n&lt; udt: has fixed member offsets?\n&lt; is forward declaration?\n&lt; is a pointer to a function?\n&lt; func: is high type\n&lt; is a shifted pointer?\n&lt; udt: is small udt (can be passed in regs)\n&lt; is a SSE vector type?\n&lt; is a typedef?\n&lt; is a variable member type?\n&lt; is a variable-size structure?\n&lt; is vftable?\n&lt; udt&amp;array: object consisting of one member: type of the …\n&lt; get initial type ordinal\n&lt; ptr&amp;array: get size of subtype\n&lt; ptr&amp;array: pointed object or array element\n&lt; ptr: pointed type\n&lt; func: number of purged bytes\n&lt; real type (do not fully resolve type refs)\n&lt; real type (fully resolve eventual type references)\n&lt; ptr: pointed type or type itself\n&lt; get type sign\n&lt; udm: was the member created due to the type system\n&lt; udt: get member TID\n&lt; udt: get number of udt members\n&lt; udt: sizeof baseclass when embedded into a derived class\n&lt; enum: add enum member\n&lt; func: add function argument\n&lt; udt: add a struct member\n&lt; set type alias\n&lt; set type alignment\n&lt; enum: make/unmake enum a bitmask\n&lt; clear ‘const/volatile’ bits\n&lt; set type comment\n&lt; set declared alignment\n&lt; enum: del enum members\n&lt; func: del function arguments\n&lt; udt: del struct members\n&lt; enum: change constant value and/or bitmask\n&lt; enum: set comment of an enum member\n&lt; enum: rename enum member\n&lt; enum: set enum radix\n&lt; enum: set enum base repr\n&lt; enum: set enum sign\n&lt; enum: set the width of enum base type\n&lt; udt: expand/shrink struct\n&lt; struct: use fixed member offsets\n&lt; func: set argument location\n&lt; func: rename a function argument\n&lt; func: set type of a function argument\n&lt; func: set calling convention\n&lt; func: set location of function return value\n&lt; func: set function return type\n&lt; set type name\n&lt; udt: set struct packing\n&lt; udt: set struct alignment\n&lt; struct: set struct size (only for fixed structs)\n&lt; set type sign\n&lt; udt: set comment of a struct member\n&lt; udt: rename a struct member\n&lt; udt: set repr of a struct member\n&lt; udm: the member is created due to the type system\n&lt; udt: set type of a struct member\n&lt; calculate udt field alignments\n&lt; set udt member functions\n&lt; size of the temporary stack part &lt; (which dynamically …\n&lt; vector of pointers to citem_t objects (nodes …\nCtree location. Used to denote comment locations.\n&lt; member type\nScattered operands always have type info assigned to them …\n&lt; formal argument type\n&lt; expression type. must be carefully maintained\n&lt; block type (BLT_NONE - not computed yet)\n\\addtogroup tattr_ext Extended type attributes @{ Extended …\nthis vector must be sorted by keys\n&lt; for stroffs: structure for offsetof()\\n &lt; for enums: …\n&lt; FRB_STROFF, FRB_ENUM\n@}\n@}\nAn object to represent struct or union members\nReimplementation of vector class from STL. Only the most …\n&lt; the comment has been retrieved?\n&lt; user-defined comments.\n&lt; user-defined item flags \\ref CIT_\n&lt; user-defined labels.\n&lt; user-defined union field selections.\nSet of address intervals. Bit arrays are efficient only …\n&lt; used for \\ref cot_var\nValue number. Zero means unknown. Operands with the same …\n&lt; attribute bytes\nVisual representation of a member of a complex type …\nAdditional info\n&lt; List of case values. &lt; if empty, then ‘default’ case\n&lt; expression values for each target\nReference to a local variable\n&lt; local variables\nHelper class to convert cfunc_t into text.\nBase helper class to convert binary data structures into …\n@}\n&lt; what memory is visible to the call?\nWarning ids\n&lt;  6 cannot handle address arithmetics in outgoing …\n&lt; 21 array has been used for an input argument\n&lt; 38 bad sp value at call\n&lt; 23 incorrect structure member type for %s::%s, ignored\n&lt; 49 bad instruction\n&lt; 48 too short map destination ‘%s’ for variable ‘%s…\n&lt; 12 inconsistent function type and number of purged bytes\n&lt; 25 wrong return variable\n&lt; 45 ignored the value written to the shadow area of the …\n&lt; 40 positive sp value %a has been found\n&lt; 37 corrupted or unexisting local type ‘%s’\n&lt; 41 wrong sp change point\n&lt; 33 user specified stroff has not been processed: %s\n&lt; 44 values range analysis failed\n&lt; 34 inconsistent variable size for ‘%s’\n&lt; 13 too many cbuild loops\n&lt; 32 CONTAINING_RECORD: too small offset %d for struct ‘…\n&lt; 31 CONTAINING_RECORD: no field ‘%s’ in struct ‘%s…\n&lt;  7 found interdependent unknown calls\n&lt; 10 failed to expand a linear variable\n&lt; 29 fixed broken insn\n&lt; 26 fragmented variable at %s may be wrong\n&lt;  9 using guessed type %s;\n&lt; 27 exceedingly huge offset into the stack frame\n&lt;  8 erroneously detected ellipsis type has been ignored\n&lt; 18 inconsistent fpu stack\n&lt;  2 invalid function type ‘%s’ has been ignored\n&lt;  1 odd caller purged bytes %d, correcting\n&lt; 43 control flows out of bounds\n&lt; may be used in notes as a placeholder when the &lt; warning …\n&lt; 22 too many input arguments, some ignored\n&lt; 39 wrong markup of switch jump, skipped it\n&lt; 17 function return type is incorrect (must be floating …\n&lt; 14 could not find valid save-restore pair for %s\n&lt; 50 encountered odd instruction for the current ABI\n&lt; 16 odd use of a variable address\n&lt; 15 odd input register %s\n&lt; 54 simplified comparisons for ‘%s’: %s became %s\n&lt; 46 conditional instruction was optimized away because %s\n&lt; 52 mask 0x%X is shortened because %s &lt;= 0x%X“\n&lt; 53 masking with 0X%X was optimized away because %s &lt;= …\n&lt; 47 returning address of temporary local variable ‘%s’\n&lt; 19 self-referencing variable has been detected\n&lt; 55 call arguments overflow the function chunk frame\n&lt; 36 unaligned function argument ‘%s’\n&lt; 51 unbalanced stack, ignored a potential tail call\n&lt; 42 variable ‘%s’ is possibly undefined\n&lt; 28 reference to an uninitialized register has been …\n&lt; 35 unsupported processor register ‘%s’\n&lt;  5 too many varargs, some ignored\n&lt;  4 call vararg without local stack\n&lt;  0 cannot handle register arguments in vararg function, …\n&lt;  3 cannot handle tail call to vararg\n&lt; 11 failed to widen chains\n&lt; 20 variables would overlap: %s\n&lt; 24 write access to const memory at %a has been detected\n&lt; 30 wrong offset of va_list variable\n&lt; variable size in bytes\n&lt; the first operand of the expression\n&lt; the second operand of the expression\n&lt; the third operand of the expression\nProcess everything in the queues and return true. \\return …\n&lt; stack\n&lt; cdecl + ellipsis\n&lt; stack, purged (x86), first args are in regs …\n&lt; (Go) arguments and return value in stack\n&lt; this value is invalid\n\\defgroup CM_CC_ Calling convention @{\n&lt; stack, purged, reverse order of args\n&lt; usercall: locations of all arguments &lt; and the return …\n&lt; ::CM_CC_SPECIAL with ellipsis\n&lt; Equal to ::CM_CC_SPECIAL, but with purged stack\n&lt; This is NOT a cc! Mark of __spoil record &lt; the low …\n&lt; stack, purged\n&lt; (Swift) arguments and return values in registers …\n&lt; stack, purged (x86), first arg is in reg …\n&lt; unknown calling convention\n&lt; function without arguments &lt; if has other cc and argnum …\n\\defgroup CM_ptr Default pointer size @{\n&lt; large:   code=far, data=far\n&lt; medium:  code=far, data=near\n@} \\defgroup CM_M_ Model @{\n&lt; compact: code=near, data=far\n&lt; small:   code=near, data=near (or unknown if CM_UNKNOWN)\n&lt; near 2 bytes, far 4 bytes\n&lt; near 4 bytes, far 6 bytes\n&lt; if sizeof(int)&gt;2: near 8 bytes, far 8 bytes\n&lt; if sizeof(int)&lt;=2: near 1 byte, far 2 bytes\n&lt; unknown\n&lt; Borland C++\n&lt; Delphi\n&lt; GNU C++\n\\defgroup COMP_ Compiler IDs @{\n&lt; Visual C++\n&lt; Unknown\n&lt; uncertain compiler id\n&lt; Visual Age C++\n&lt; Watcom C++\n&lt; memory model and calling convention (see \\ref CM_)\nInformation about the target compiler\n&lt; default alignment for structures\n&lt; AIX ar library\n&lt; Linux a.out (AOUT)\n&lt; ar library\n&lt; Binary File\n&lt; Common Object File Format (COFF)\n&lt; MS DOS COM File\n&lt; MS DOS COM File\n&lt; MS DOS Driver\n&lt; Executable and Linkable Format (ELF)\n&lt; MS DOS EXE File\n&lt; MS DOS EXE File\n&lt; Intel Hex Object File\n&lt; Linear Executable (LE)\n&lt; file is loaded using LOADER DLL\n&lt; Linear Executable (LX)\n&lt; Mac OS X Mach-O\n&lt; Mediatek Firmware Image\n&lt; MOS Technology Hex Object File\n&lt; Netware Loadable Module (NLM)\n&lt; Object Module Format\n&lt; Library of OMF Modules\n&lt; Portable Executable (PE)\n&lt; PalmPilot program file\n&lt; Sony Playstation PSX object file\n&lt; Motorola SREC (S-record)\n&lt; Watcom DOS32 Extender (W32RUN)\n&lt; New Executable (NE)\n&lt; ZIP file (this file is never loaded to IDA database)\nKnown input file formats (kept in \\inf{filetype}):\nReturns the argument unchanged.\nReturns the argument unchanged.\n&lt; compiler id (see \\ref COMP_)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n&lt; sizeof(bool)\n&lt; sizeof(enum)\n&lt; sizeof(int)\n&lt; long\n&lt; longdouble (if different from \\ph{tbyte_size})\n&lt; longlong\n&lt; short\n&lt; Memory Ref [Base Reg + Index Reg + Displacement].\n&lt; Immediate Far Address  (CODE).\n&lt; processor specific type.\n&lt; processor specific type.\n&lt; processor specific type.\n&lt; processor specific type.\n&lt; processor specific type.\n&lt; processor specific type. &lt; (there can be more processor …\n&lt; Immediate Value.\n&lt; Direct Memory Reference  (DATA).\n&lt; Immediate Near Address (CODE).\n&lt; Memory Ref [Base Reg + Index Reg].\n&lt; General Register (al,ax,es,ds…).\n&lt; No Operand.\nSynthesized copy constructor.\nSynthesized destructor.\nFind a user-defined plugin and optionally load it. \\param …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSynthesized move constructor.\nA plugin is a module in the plugins subdirectory that can …\nRun a loaded plugin with the specified argument. \\param …\n&lt; virtual address pointed or used by the operand. &lt; …\n&lt; processor dependent field\nCurrent segment base paragraph. Initialized by the kernel.\nType of operand value (see \\ref dt_). Usually first 9 …\nLinear address of the instruction. Initialized by the …\n&lt; \\ref OF_\n&lt; \\ref INSN_\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n&lt; IBM PC: segment selector value  …\nStructure to hold information about an instruction. …\n&lt; processor dependent field\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nVirtual address of the instruction (address within the …\nInternal code of instruction (only for canonical insns - …\n&lt; IBM PC: segment register number …\nNumber of operand (0,1,2). Initialized once at the start …\nOffset of operand value from the instruction start (0 …\nSame as #offb (some operands have 2 numeric values used to …\nOperand of an instruction. \\ingroup operands_t This …\n@}\nThis structure is defined for your convenience only\nThis structure is defined for your convenience only\nThis structure is defined for your convenience only\n&lt; array of operands\n\\defgroup operands Operands Work with instruction operands\n&lt; number of register phrase (::o_phrase,::o_displ). &lt; you …\n&lt; number of register (::o_reg)\n&lt; processor dependent field\nSize of instruction in bytes. The analyzer should put here …\n\\name Special flags The following fields are used only in …\n&lt; This field may be used as you want.\nType of operand (see \\ref o_)\n&lt; operand value (::o_imm) or &lt; outer displacement …\nSynthesized destructor.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDescribes a processor module (IDP). An IDP file may have …\nSynthesized copy constructor.\nSynthesized copy constructor.\nSynthesized destructor.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet pointer to segment by its name. If there are several …\nGet number of segments\nGet pointer to segment by its number. \\warning Obsoleted …\nGet pointer to segment by linear address. \\param ea  …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHelper class to lock a segment pointer so it stays valid\nSynthesized move constructor.\nDescribes a program segment\nRebuild the string list.\nClear the string list.\nGet number of elements in the string list. The list will …\nIf the instruction at ‘ea’ looks like an alignment …\nIs the instruction the end of a basic block?\nIs the instruction a “call”?\nIs the instruction an indirect jump?\n@}\nGet start of next defined item. \\param ea     begin search …\nGet start of previous defined item. \\param ea     begin …\nSynthesized copy constructor.\nCODE xref types\n&lt; Informational &lt; (a derived java class references its base\n&lt; Offset &lt; The reference uses ‘offset’ of data &lt; …\n&lt; Read access\n&lt; Reference to enum member (symbolic constant)\n&lt; Text (for forced operands only) &lt; Name of data is used …\n&lt; Unknown – for compatibility with old &lt; versions. …\n&lt; Write access\nDATA xref types\nSynthesized destructor.\n&lt; Call Far &lt; This xref creates a function at the &lt; …\n&lt; Call Near &lt; This xref creates a function at the &lt; …\n&lt; Ordinary flow: used to specify execution &lt; flow to the …\n&lt; Jump Far\n&lt; Jump Near\n&lt; unknown – for compatibility with old &lt; versions. …\n&lt; User specified (obsolete)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n&lt; the referencing address - filled by first_to(),next_to()\nDoes ‘ea’ have references from outside of ‘pfn’?\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n&lt; is code reference (::cref_t)? &lt; otherwise it is a data …\nSynthesized move constructor.\n&lt; the referenced address - filled by first_from(), …\n&lt; type of the last returned reference (::cref_t &amp; ::dref_t)\n&lt; is user defined xref? otherwise defined by ida\nStructure to enumerate all xrefs. This structure provides …\n\\name Helper functions Should not be called directly! @{")