searchState.loadedDescShard("autocxx", 0, "Autocxx\nAny type which can return a C++ reference to its contents.\nAny type which can return a C++ reference to its contents.\nautocxx couldn’t generate these bindings. If you come …\nA C++ non-const reference. These are different from Rust’…\nA newtype wrapper which causes the contained object to …\nA C++ const reference. These are different from Rust’s <code>&amp;T</code>…\nAny newtype wrapper which causes the contained <code>UniquePtr</code> …\nEquivalent to <code>std::convert::AsMut</code>, but returns a pinned …\nA trait representing a parameter to a C++ function which …\nA trait representing a parameter to a C++ function which …\nProvides utility functions to emplace any <code>moveit::New</code> into …\nEmulates the <code>WithinBox</code> trait, but for trivial (plain old …\nProvides utility functions to emplace any <code>moveit::New</code> into …\nEmulates the <code>WithinUniquePtr</code> trait, but for trivial (plain …\nExplicitly force a value parameter to be taken by copy.\nReturns a mutable reference which obeys C++ reference …\nReturns a reference which obeys C++ reference semantics\nExplicitly force a value parameter to be taken using C++ …\nGet a regular Rust mutable reference out of this C++ …\nGet a normal Rust mutable reference to the underlying …\nRetrieve the underlying C++ pointer.\nGet a mutable pointer to the underlying object.\nExplicitly force a value parameter to be taken using any …\nRetrieve the underlying C++ pointer.\nGet an immutable pointer to the underlying object.\nGet an immutable pointer to the underlying object.\nGet a regular Rust reference out of this C++ reference.\nGet a normal Rust reference to the underlying object. This …\nEntirely block some type from appearing in the generated …\nAvoid generating implicit constructors for this type. The …\nA C++ <code>char16_t</code>\nNewtype wrapper for an int\nNewtype wrapper for a long\nNewtype wrapper for a long long\nNewtype wrapper for an short\nNewtype wrapper for an unsigned char\nNewtype wrapper for an unsigned int\nNewtype wrapper for an unsigned long\nNewtype wrapper for an unsigned long long\nNewtype wrapper for an unsigned short\nNewtype wrapper for a C void. Only useful as a <code>*c_void</code>\nA concrete type to make, for example …\nCreate a mutable version of this reference, roughly …\nRe-export cxx such that clients can use the same version as\nWhether to avoid generating <code>cxx::UniquePtr</code> and <code>cxx::Vector</code> …\nSkip the normal generation of a <code>make_string</code> function and …\nIndicates that a C++ type is not to be generated by …\nIndicates that a C++ type is not to be generated by …\nTools to export Rust code to C++.\nSee <code>extern_rust::extern_rust_type</code>.\nExtract the object from within its prison, for re-use …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nImprison the boxed Rust data within a <code>CppPin</code>. This …\nRust references (since we take the item by value) and this …\nCreate a C++ reference from a raw pointer.\nCreate a C++ reference from a raw pointer.\nGenerate Rust bindings for the given C++ type or function. …\nGenerate Rust bindings for all C++ types and functions …\nGenerate Rust bindings for all C++ types and functions in …\nGenerate as “plain old data” and add to allowlist. …\nInclude a C++ header. A directive to be included inside …\nInclude some C++ headers in your Rust project.\nIndicates that a C++ type can definitely be instantiated. …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nExtend the lifetime of the returned reference beyond …\nExtend the lifetime of the returned reference beyond …\nRe-export moveit for ease of consumers.\nThe name of the mod to be generated with the FFI code. The …\nImprison the Rust data within a <code>CppPin</code>. This eliminates …\nImprison the type within a <code>CppPin</code>. This eliminates any …\nReturn a pinned mutable reference to a type.\nGenerate as “plain old data”. For use with generate_all\nImports which you’re likely to want to use.\nDeprecated - use <code>extern_rust_type</code> instead.\nSpecifies a global safety policy for functions generated …\nModule to make Rust subclasses of C++ classes. See …\nSee <code>subclass::subclass</code>.\nCreate this item inside a pinned box. This is a good …\nCreate this item inside a <code>CppPin</code>. This is a good option if …\nCreate this item within a <code>cxx::UniquePtr</code>.\nDeclare that a given function is a Rust function which is …\nDeclare that this is a Rust type which is to be exported …\nA pointer type that may be “emplaced” as a stable …\nAn in-place constructor for a particular type.\nThe type to construct.\nThe stable address type within which a value of type <code>T</code> is …\nBinding to C++ <code>std::unique_ptr&lt;T, std::default_delete&lt;T&gt;&gt;</code>.\nReturns a mutable pinned reference to the object owned by …\nReturns a raw mutable pointer to the object owned by this …\nReturns a raw const pointer to the object owned by this …\nReturns a reference to the object owned by this UniquePtr …\nAttribute which should never be encountered in real life. …\nConstructs a new smart pointer and emplaces <code>n</code> into its …\nReturns the argument unchanged.\nConstructs a UniquePtr retaking ownership of a pointer …\nInclude some C++ headers in your Rust project.\nCalls <code>U::from(self)</code>.\nConsumes the UniquePtr, releasing its ownership of the …\nChecks whether the UniquePtr does not own an object.\nPerforms an emplacement operation.\nConstruct a new value using the arguments stored in <code>self</code>.\nAllocates memory on the heap and makes a UniquePtr …\nMakes a new UniquePtr wrapping a null pointer.\nReturns a mutable pinned reference to the object owned by …\nConstructs a new smart pointer and tries to emplace <code>n</code> into …\nAdds a post-construction operation.\nA trait to be implemented by a subclass which knows how to …\nA subclass of a C++ type.\nProvides default constructors for subclasses which …\nTrait to be implemented by subclasses which are …\nProvides default constructors for subclasses which …\nCreate a C++-owned instance of this subclass, initializing …\nCreate a Rust-owned instance of this subclass, …\nCreate a self-owned instance of this subclass, …\nRelinquishes ownership from the C++ side. If there are no …\nDeprecated - use <code>subclass</code> instead. Attribute to state that …\nCreate the C++ peer. This method will be automatically …\nCreates a new instance of this subclass. This instance is …\nCreates a new instance of this subclass. This instance is …\nCreates a new instance of this subclass which owns itself. …\nReturn a reference to the C++ part of this object pair. …\nReturn the field which holds the C++ peer object. This is …\nReturn the field which holds the C++ peer object. This is …\nReturn a mutable reference to the C++ part of this object …\nA prelude containing all the traits and macros required to …\nDeclare a Rust subclass of a C++ class. You can use this …\nDeprecated - use <code>subclass</code> instead. Attribute to state that …\nDeclare a Rust subclass of a C++ class. You can use this …")