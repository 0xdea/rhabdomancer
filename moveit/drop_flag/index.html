<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Drop flags."><title>moveit::drop_flag - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-84e720fa.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="moveit" data-themes="" data-resource-suffix="" data-rustdoc-version="1.89.0 (29483883e 2025-08-04)" data-channel="1.89.0" data-search-js="search-92309212.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-4e99c027.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-fd3af306.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../moveit/index.html">moveit</a><span class="version">0.6.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module drop_<wbr>flag</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#safety" title="Safety">Safety</a></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate moveit</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">moveit</a></div><h1>Module <span>drop_flag</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/moveit/drop_flag.rs.html#15-334">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Drop flags.</p>
<p>The <a href="https://doc.rust-lang.org/1.89.0/core/pin/struct.Pin.html" title="struct core::pin::Pin"><code>Pin&lt;P&gt;</code></a> guarantees state that if we have a <code>T</code> allocated somewhere,
and we construct a pinned reference to it such as a <code>Pin&lt;&amp;'a mut T&gt;</code>, then
before that “somewhere” in memory is reused by another Rust object, <code>T</code>’s
destructor must run.</p>
<p>Normally, this isn’t a problem for Rust code, since the storage of an object
is destroyed immediately after it is destroyed. <a href="../move_ref/trait.DerefMove.html" title="trait moveit::move_ref::DerefMove"><code>DerefMove</code></a>, however,
breaks this expectation: it separates the destructors from its storage and
contents into two separately destroyed objects: a <a href="../move_ref/trait.AsMove.html#associatedtype.Storage" title="associated type moveit::move_ref::AsMove::Storage"><code>AsMove::Storage</code></a> and a
<a href="../move_ref/struct.MoveRef.html" title="struct moveit::move_ref::MoveRef"><code>MoveRef</code></a>. If the <a href="../move_ref/struct.MoveRef.html" title="struct moveit::move_ref::MoveRef"><code>MoveRef</code></a> is <a href="https://doc.rust-lang.org/1.89.0/core/mem/fn.forget.html" title="fn core::mem::forget"><code>mem::forget</code></a>’ed, we lose: the storage
will potentially be re-used.</p>
<p>Therefore, we must somehow detect that <a href="../move_ref/struct.MoveRef.html" title="struct moveit::move_ref::MoveRef"><code>MoveRef</code></a>s fail to be destroyed
when the destructor for the corresponding storage is run, and remediate it,
either by leaking heap storage or aborting if we would free stack storage
(a panic is insufficient, since that location can be reused if the panic is
caught).</p>
<p>A <a href="struct.DropFlag.html" title="struct moveit::drop_flag::DropFlag"><code>DropFlag</code></a> allows us to achieve this. It is a generalized, library-level
version of the Rust language’s drop flags, which it uses to dynamically
determine whether to run destructors of stack-allocated values that might
have been moved from. Unlike Rust language drop flags, a <a href="struct.DropFlag.html" title="struct moveit::drop_flag::DropFlag"><code>DropFlag</code></a> is
actually a counter, rather than a boolean. This allows storage that holds
many objects, like a vector, ensure that all contents have been properly
destroyed.</p>
<p>This module also provides two helper types simplify safe creation and
management of drop flags.</p>
<p>See the <a href="https://doc.rust-lang.org/nomicon/drop-flags.html">Rustonomicon entry</a>
for the Rust language equivalent.</p>
<h2 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h2>
<p>No function in this module is <code>unsafe</code>: instead, functions that construct
<a href="../move_ref/struct.MoveRef.html" title="struct moveit::move_ref::MoveRef"><code>MoveRef</code></a>s out of <a href="struct.DropFlag.html" title="struct moveit::drop_flag::DropFlag"><code>DropFlag</code></a>s are <code>unsafe</code>, and their callers are
responsible for ensuring that the passed-in <a href="struct.DropFlag.html" title="struct moveit::drop_flag::DropFlag"><code>DropFlag</code></a> helps uphold the
relevant invariants.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.DropFlag.html" title="struct moveit::drop_flag::DropFlag">Drop<wbr>Flag</a></dt><dd>A drop flag, for tracking successful destruction.</dd><dt><a class="struct" href="struct.DroppingFlag.html" title="struct moveit::drop_flag::DroppingFlag">Dropping<wbr>Flag</a></dt><dd>A wrapper for managing when a value gets dropped via a <a href="struct.DropFlag.html" title="struct moveit::drop_flag::DropFlag"><code>DropFlag</code></a>.</dd><dt><a class="struct" href="struct.QuietFlag.html" title="struct moveit::drop_flag::QuietFlag">Quiet<wbr>Flag</a></dt><dd>A <a href="struct.DropFlag.html" title="struct moveit::drop_flag::DropFlag"><code>DropFlag</code></a> source that doesn’t do anything with it.</dd><dt><a class="struct" href="struct.TrappedFlag.html" title="struct moveit::drop_flag::TrappedFlag">Trapped<wbr>Flag</a></dt><dd>An RAII trap that ensures a drop flag is correctly cleared.</dd></dl></section></div></main></body></html>